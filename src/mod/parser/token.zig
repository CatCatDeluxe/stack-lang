const std = @import("std");
const Scanner = @import("../text/scanner.zig");
const Charset = @import("../text/charset.zig");

const Token = @This();

/// All whitespace characters.
pub const chars_whitespace = Charset.set(" \n\t\r");
/// TODO: change number parsing to ensure literals are valid while tokenizing
pub const chars_num_start = Charset.range('0', '9');
/// All characters possibly present in a number.
///
/// TODO: change number parsing to ensure literals are valid while tokenizing
pub const chars_num = Charset.set(.{chars_num_start, '_', '.', 'e'});
/// All characters that can start an alphanumeric name. Contains only a-z and A-Z.
pub const chars_name_start = Charset.set(.{Charset.range('a', 'z')});
/// All characters allowed in a alphanumeric name.
pub const chars_name = Charset.set(.{chars_name_start, Charset.range('0', '9'), Charset.range('A', 'Z')});
/// All characters included in an operator name
pub const chars_operator = Charset.set("+-*/~=<>^&%");

pub const block_comment_start = "--(";
pub const block_comment_end = ")--";

pub const Type = enum {
	lbracket, rbracket,
	lcurly, rcurly,
	lsquare, rsquare,
	/// An alphanumeric name.
	name_regular,
	/// A name consisting of operator characters.
	name_operator,
	/// Not used yet
	sym_dot,
	/// A colon, used to separate the names from the code in a match block.
	sym_colon,
	/// A pipe, used to separate match blocks.
	sym_pipe,
	/// An operator used to call the top value of the stack.
	sym_call,
	/// Used to separate definitions
	sym_comma,
	/// Used in definitions
	sym_double_colon,
	/// An operator that returns a reference to the current function.
	sym_this_func,
	/// Some text that can be parsed as a number.
	number,
	/// A symbol (a string later compiled down to an int)
	symbol,
	/// A string. Because of limitationsm the token's text contains the surrounding quotes. Use `innerText` to get the text without them.
	string,
	/// A comment. Can be ignored.
	comment,
	/// The end of a file or string.
	end,
	/// A placeholder for a place that requires a token but no proper token exists.
	/// This cannot be generated by `read()`.
	empty,
	/// Used to indicate something outside of regular code
	directive,

	pub fn isName(t: Type) bool {
		return t == .name_regular or t == .name_operator;
	}

	/// Returns the opening/closing counterpart to a closing/opening token type.
	/// If the token type does not have a counterpart, panics.
	pub fn counterpart(t: Type) Type {
		return switch (t) {
			.lbracket => .rbracket,
			.lcurly => .rcurly,
			.lsquare => .rsquare,
			.rbracket => .lbracket,
			.rcurly => .lcurly,
			.rsquare => .lsquare,
			else => std.debug.panic("Token type {} does not have a closing/opening counterpart", .{t}),
		};
	}
};

/// The token type.
type: Type,
/// The token text
text: []const u8,
/// The position in the source string
position: Scanner.State,

/// Returns a placeholder token, with location information.
pub fn empty(s: Scanner.State) Token {
	return Token {.type = .empty, .text = &.{}, .position = s};
}

fn new(p: *Scanner, tp: Type, n: usize) Token {
	return .{
		.type = tp,
		.position = p.state,
		.text = p.eat(n),
	};
}

/// Returns the inner text of the token, without any included delimiters.
/// For `string`s, returns the text without quotes.
pub fn innerText(self: Token) []const u8 {
	switch (self.type) {
		.string => {
			if (self.text.len < 2) return &.{};
			return self.text[1..self.text.len - 1];
		},
		else => return self.text,
	}
}

/// For a scanner running on the value of `innerText`, returns the position of its current state in
/// the token's file, using its `position` member.
pub fn getGlobalPos(self: Token, scanner_state: Scanner.State) Scanner.State {
	const initial_offset: u16 = switch (self.type) {
		.string => 1,
		else => 0,
	};
	var res = scanner_state;
	res.position += initial_offset;
	res.line += scanner_state.line;
	if (scanner_state.line == 0) {
		res.col += initial_offset + scanner_state.col;
	} else {
		res.col = scanner_state.col;
	}
	return res;
}

/// Eats a name from `s`. Assumes that the current next character is a valid start to the name.
fn eatName(s: *Scanner) []const u8 {
	const chars_separator = Charset.set(.{'-', '_'});

	const start = s.state.position;
	s.advance(1);

	while (s.valid()) {
		_ = s.eatIn(chars_name);

		// after eating all name chars, can only continue if there is a separator
		if (!chars_separator.has(s.nextc())) break;

		const save_state = s.state;
		s.advance(1);
		if (!chars_name.has(s.nextc())) {
			// there is no regular name character after the separator.
			// leave the trailing separator as not part of the name, and
			// rewind to before it.
			s.state = save_state;
			break;
		}
	}

	return s.text[start..s.state.position];
}

fn eatIdent(s: *Scanner) ?Token {
	const c = s.nextc();
	if (chars_name_start.has(c)) {
		return .{
			.type = .name_regular,
			.position = s.state,
			.text = eatName(s),
		};
	} else if (chars_operator.has(c)) {
		return .{
			.type = .name_operator,
			.position = s.state,
			.text = s.eatIn(chars_operator),
		};
	}
	return null;
}

/// gets the next token from the parser `p`. does not advance the scanner.
/// if the next token is invalid, returns `null`.
pub fn read(p_in: Scanner) ?Token {
	var p = p_in;
	if (!p.valid()) return .new(&p, .end, 0);

	const c = p_in.nextc();

	if (c == '"') {
		p.advance(1);
		while (p.valid()) {
			switch (p.nextc()) {
				'\\' => p.advance(2),
				'"' => {
					p.advance(1);
					break;
				},
				else => p.advance(1),
			}
		}
		return .{
			.type = .string,
			.position = p_in.state,
			.text = p_in.next(p.state.position - p_in.state.position),
		};
	}

	// Handle comments
	if (c == '-' and p.peekc(1) == '-') {
		// multiline comments
		if (p.nextIs(block_comment_start)) {
			while (p.valid()) {
				if (p.nextIs(block_comment_end)) {
					break;
				}
				p.advance(1);
			}
			const len = p.state.position - p_in.state.position;
			return .{
				.type = .comment,
				.position = p_in.state,
				.text = p_in.next(len),
			};
		}
		// regular comments
		// eat until the next newline, and then eat the newline
		return .{
			.type = .comment,
			.position = p.state,
			.text = p.eatIn(Charset.set(.{'\n'}).inv()),
		};
	}

	// parse a symbol
	if (c == '\'') {
		p.advance(1);
		return .{
			.type = .symbol,
			.position = p.state,
			.text = (eatIdent(&p) orelse return null).text,
		};
	}

	// parse a directive
	if (c == '#') {
		p.advance(1);
		return .{
			.type = .directive,
			.position = p.state,
			.text = (eatIdent(&p) orelse return null).text,
		};
	}

	if (c == ':') {
		if (p.peekc(1) == ':') {
			return .{
				.type = .sym_double_colon,
				.position = p.state,
				.text = p.eat(2),
			};
		}
		return .{
			.type = .sym_colon,
			.position = p.state,
			.text = p.eat(1),
		};
	}

	// Names may start only with a..z.
	// They may then contain an arbitrary amount blocks of a..z and 0..9,
	// and these blocks may be separated by a single '-' or '_'. Trailing '-'
	// or '-' are not included in the name.
	if (eatIdent(&p)) |ident| return ident;

	if (chars_num_start.has(c)) {
		return .{
			.type = .number,
			.position = p.state,
			.text = p.eatIn(chars_num),
		};
	}

	return switch (c) {
		'!' => .new(&p, .sym_call, 1),
		'@' => .new(&p, .sym_this_func, 1),
		'_' => .new(&p, .name_regular, 1),
		'(' => .new(&p, .lbracket, 1),
		')' => .new(&p, .rbracket, 1),
		'{' => .new(&p, .lcurly, 1),
		'}' => .new(&p, .rcurly, 1),
		'[' => .new(&p, .lsquare, 1),
		']' => .new(&p, .rsquare, 1),
		'|' => .new(&p, .sym_pipe, 1),
		'.' => .new(&p, .sym_dot, 1),
		',' => .new(&p, .sym_comma, 1),
		else => null,
	};
}

/// Eats a created token. puts the parser at the end of that token.
pub fn eat(t: Token, p: *Scanner) void {
	p.state = t.position;
	p.advance(t.text.len);
}

/// Expects that the tokens parsed from text have the same types in the same order as
/// `expected_types`. If it is expected that a token cannot be parsed, use `null`
/// in `expected_types`.
fn expectParsesTo(text: []const u8, expected_types: []const ?Token.Type) !void {
	var s = Scanner {.text = text};

	var arr = std.array_list.Managed(?Token.Type).init(std.testing.allocator);
	defer arr.deinit();

	while (true) {
		_ = s.eatIn(Token.chars_whitespace);
		if (Token.read(s)) |tk| {
			try arr.append(tk.type);
			tk.eat(&s);
			if (tk.type == .end) break;
		} else {
			try arr.append(null);
			break;
		}
	}

	try std.testing.expectEqualSlices(?Token.Type, expected_types, arr.items);
}

test "numbers" {
	// TODO
}

test "names" {
	// names can be joined with - and _. They may not start with uppercases.
	try expectParsesTo("name-one name_underscores_2 nameCamelCase3 AnInvalidName", &.{
		.name_regular, .name_regular, .name_regular, null
	});
	try expectParsesTo("-name- na-me--", &.{
		.name_operator, .name_regular, .name_operator,
		.name_regular, .comment,
		.end
	});
	try expectParsesTo("__na_me_", &.{
		.name_regular, .name_regular, // leading underscores
		.name_regular, // actual name
		.name_regular, // trailing underscore
		.end,
	});
}

test "split tokens" {
	try expectParsesTo("x y + \n\t (a:|:) -- z", &.{
		.name_regular, .name_regular, .name_operator,
		.lbracket,
		.name_regular, .sym_colon, .sym_pipe, .sym_colon,
		.rbracket,
		.comment, .end
	});
}