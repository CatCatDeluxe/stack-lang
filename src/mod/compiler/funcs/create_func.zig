//! Contains a pre-compiled function body.
const std = @import("std");
const Allocator = std.mem.Allocator;
const Instruction = @import("../instruction.zig");
const Self = @This();

/// What to allocated code with
alloc: std.mem.Allocator,
/// The code of the function
code: std.ArrayList(CodeItem),
/// Information used for generating labels
label: packed struct(Label) {
	/// The last used label ID.
	last_id: u24 = 0,
	/// Sub-functions will have a func_id 1 higher than their parent, to
	/// ensure the generation of unique labels.
	func_id: u8 = 0,
},

pub const Label = u32;

const Jump = struct {
	/// The instruction to generate this jump off of. When `resolve` is called, only the jump offset
	/// is changed in this value. Only a subset of instructions are allowed (the ones that jump).
	base: Instruction,
	/// The target label of the instruction.
	to: Label,

	fn resolve(self: Jump, offs: isize) Instruction {
		var res = self.base;
		switch (self.base.data) {
			.jump => res.data.jump = @intCast(offs),
			.jump_if => res.data.jump_if = @intCast(offs),
			.jump_unless => res.data.jump_unless = @intCast(offs),
			.fail_check => res.data.fail_check = @intCast(offs),
			.fail_check_if_false => res.data.fail_check_if_false = @intCast(offs),
			.branch_check_begin => res.data.branch_check_begin.jump = @intCast(offs),
			else => std.debug.panic("Instruction is not a jump: {s}", .{@tagName(self.base.data)}),
		}
		return res;
	}
};

const CodeItem = union(enum) {
	jump: Jump,
	label: Label,
	instruction: Instruction,
	/// For internal use only, to allow O(1) removal of instructions.
	empty,

	fn from(i: Instruction) CodeItem {
		return .{.instruction = i};
	}
};

/// Contains a pointer to the contents of a code item.
/// All `CodeItemPtr`s are invalidated if the `CreateFunc`'s contents are changed.
pub const CodeItemPtr = union(enum) {
	jump: *Jump,
	label: *Label,
	instruction: *Instruction,
};

pub fn init(alloc: Allocator) @This() {
	return .{
		.alloc = alloc,
		.code = .empty,
		.label = .{},
	};
}

pub fn append(self: *@This(), i: Instruction) Allocator.Error!void {
	try self.code.append(self.alloc, .from(i));
}

pub fn appendJump(self: *@This(), label_id: Label, base: Instruction) Allocator.Error!void {
	try self.code.append(self.alloc, .{.jump = .{.base = base, .to = label_id}});
}

/// Creates a sub-body for the function. Once finished, can be inserted with `appendSub`.
/// Appending a `CreateFunc` not generated by this is an error and is checked for, as otherwise
/// labels would not generate correctly.
pub fn sub(self: @This()) @This() {
	return .{
		.alloc = self.alloc,
		.code = .empty,
		.label = .{
			.last_id = 0,
			.func_id = self.label.func_id + 1,
		},
	};
}

/// Appends the code of `sub` to `this`. `sub` must be a sub-body of `this`.
/// Does not deinit `sub`.
pub fn appendSub(self: *@This(), sub_body: @This()) Allocator.Error!void {
	std.debug.assert(self.label.func_id + 1 == sub_body.label.func_id);
	try self.code.appendSlice(self.alloc, sub_body.code.items);
}

/// Inserts the provided instructions before index `before`. Any labels at
/// position `before` or after will be shifted.
pub fn insert(self: *@This(), before: usize, code: []const Instruction) Allocator.Error!void {
	const slice = try self.code.addManyAt(self.alloc, before, code.len);
	for (slice, code) |*item, *i| {
		item.* = .from(i.*);
	}
}

/// Removes the instruction at `pos`. O(1) time.
/// Returns the removed item. Does not invalidate element pointers.
/// If using an iterator, use the iterator's `index` instead of `pos`.
pub fn remove(self: *@This(), pos: usize) CodeItem {
	const res = self.code.items[pos];
	self.code.items[pos] = .{.empty = {}};
	return res;
}

/// Generates a new label ID. Its location is not yet set, use `setLabel` for that.
/// If a label is never set, all jumps to it will have their offset set to 0.
pub fn newLabel(self: *@This()) Label {
	self.label.last_id += 1;
	return @bitCast(self.label);
}

/// Sets a label's position to jump to the next instruction added.
/// Calling multiple times for the same label is not valid.
pub fn setLabel(self: *@This(), id: Label) Allocator.Error!void {
	try self.code.append(self.alloc, .{.label = id});
}

const Iter = struct {
	parent: *const Self,
	/// The index in the `CreateFunc`'s data array. This does not correspond to instruction position.
	/// Initial value is maxInt(usize)
	index: usize = start,
	/// The *instruction* index of the iterator. This is the actual instruction index of the
	/// current item, and does not increase when encountering labels.
	/// Initial value is maxInt(usize)
	pos: usize = start,

	read_index: usize = 0,
	read_pos: usize = 0,

	const start = std.math.maxInt(usize);

	// code:
	// :a - 0
	// add - 0
	// add - 1
	// :b - 1
	// add - 2

	/// Gets the next `CodeItemPtr`.
	pub fn next(self: *@This()) ?CodeItemPtr {
		return self.mpeek(1, true);
	}

	/// Peeks at the next code item `offset` from the current position.
	pub fn peek(self: @This(), offset: usize) ?CodeItemPtr {
		var s = self;
		return s.mpeek(offset, true);
	}

	/// Similar to `peek`, but skips over labels and only returns instructions and jumps.
	pub fn instructionPeek(self: @This(), offset: usize) ?CodeItemPtr {
		var s = self;
		return s.mpeek(offset, false);
	}

	fn mpeek(self: *@This(), count: usize, count_labels: bool) ?CodeItemPtr {
		var n = count;
		while (n > 0) {
			self.index +%= 1;
			if (self.index >= self.parent.code.items.len) return null;
			switch (self.parent.code.items[self.index]) {
				.instruction, .jump => {
					self.pos +%= 1;
					n -= 1;
				},
				.label => if (count_labels) {
					if (self.pos == start) self.pos = 0;
					n -= 1;
				},
				.empty => {},
			}
		}

		const item = &self.parent.code.items[self.index];
		return switch (item.*) {
			.instruction => .{.instruction = &item.instruction},
			.jump => .{.jump = &item.jump},
			.label => .{.label = &item.label},
			.empty => unreachable,
		};
	}
};

/// Returns an iterator over all items of the func.
pub fn items(self: *const @This()) Iter {
	return .{.parent = self};
}

pub fn deinit(self: *@This()) void {
	self.code.deinit(self.alloc);
}

/// Finalizes the Func to an instruction array, allocated with `to_alloc`.
pub fn finalize(self: *@This(), to_alloc: Allocator) Allocator.Error![]Instruction {
	// for each label, iterate over all unresolved jumps to the label and resolve them to
	// instructions with set offsets
	var label_iter = self.items();
	while (label_iter.next()) |main_item| switch (main_item) {
		.label => |label_id| {
			const label_pos = label_iter.pos;
			var jump_iter = self.items();
			while (jump_iter.next()) |jump_item| {
				const jump: *Jump = switch (jump_item) {.jump => |j| j, else => continue};
				if (jump.to != label_id.*) continue;

				const diff: isize =
					if (label_pos >= jump_iter.pos) @intCast(label_pos - jump_iter.pos)
					else -@as(isize, @intCast(label_pos - jump_iter.pos));

				self.code.items[jump_iter.index] = .{.instruction = jump.resolve(diff + 1)};
			}
		},
		else => {},
	};

	// TODO: optimize to realloc instead of new alloc + free
	// resolving is always possible in-place because sizeof(CodeItem) >= sizeof(Instruction)

	const output_size = label_iter.pos +% 1; // no instructions iterated => pos = maxInt(usize), so wrap
	const res = try to_alloc.alloc(Instruction, output_size);

	// set any unresolved jumps to have an offset of 0
	var iter = self.items();
	while (iter.next()) |item| {
		switch (item) {
			.jump => |j| res[iter.pos] = j.resolve(0),
			.instruction => |ins| res[iter.pos] = ins.*,
			.label => {},
		}
	}

	self.code.clearAndFree(self.alloc);
	return res;
}

/// Returns the number of instructions that would be generated if `finalize` was called right now.
fn getOutputSize(self: @This()) usize {
	var res: usize = 0;

	for (self.code.items) |*i| switch (i.*) {
		.jump, .instruction => res += 1,
		.label, .empty => {},
	};

	return res;
}